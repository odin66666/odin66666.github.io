"""
Sistema di tracking per incantesimi (Mantra, Necronomicon, Aura)
Stessa logica dei lavori runici:
- Il giorno inizia all'alba (6:00)
- Recovery mode per giorni persi (2 sessioni a 6 ore di distanza)
- Salva progresso, statistiche e storico
"""

import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional

# File per salvare i dati
SPELL_TRACKER_FILE = Path(__file__).parent / "spell_tracker_data.json"


def load_tracker_data() -> dict:
    """Carica i dati del tracker"""
    if SPELL_TRACKER_FILE.exists():
        try:
            with open(SPELL_TRACKER_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_tracker_data(data: dict):
    """Salva i dati del tracker"""
    with open(SPELL_TRACKER_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def get_dawn_today() -> datetime:
    """
    Ottiene l'alba di oggi (6:00 come default).
    Il giorno planetario inizia all'alba, non a mezzanotte.
    """
    now = datetime.now()
    dawn = now.replace(hour=6, minute=0, second=0, microsecond=0)
    return dawn


def check_already_done_today(work: Dict) -> bool:
    """
    Verifica se il lavoro √® gi√† stato fatto oggi (dall'ultima alba).
    Ritorna True se GIA' FATTO oggi.
    """
    last_completed = work.get("last_completed")
    if not last_completed:
        return False
    
    try:
        if isinstance(last_completed, str):
            last_dt = datetime.fromisoformat(last_completed.replace('Z', '+00:00').replace('+00:00', ''))
        else:
            last_dt = last_completed
        
        dawn_today = get_dawn_today()
        now = datetime.now()
        
        # Se siamo prima dell'alba, l'ultimo giorno valido √® l'alba di ieri
        if now.hour < 6:
            dawn_today = dawn_today - timedelta(days=1)
        
        # Se l'ultimo completamento √® dopo l'alba di oggi, √® gi√† stato fatto
        if last_dt >= dawn_today:
            return True
        
        return False
    except Exception as e:
        print(f"[ERROR] check_already_done_today: {e}")
        return False


def check_missed_day(work: Dict) -> bool:
    """
    Verifica se √® stato saltato un giorno.
    Ritorna True se ha saltato ieri.
    """
    last_completed = work.get("last_completed")
    if not last_completed:
        return False
    
    try:
        if isinstance(last_completed, str):
            last_dt = datetime.fromisoformat(last_completed.replace('Z', '+00:00').replace('+00:00', ''))
        else:
            last_dt = last_completed
        
        dawn_today = get_dawn_today()
        now = datetime.now()
        
        # Se siamo prima dell'alba, usiamo l'alba di ieri
        if now.hour < 6:
            dawn_today = dawn_today - timedelta(days=1)
        
        dawn_yesterday = dawn_today - timedelta(days=1)
        
        # Se l'ultimo completamento √® prima dell'alba di ieri, ha saltato
        if last_dt < dawn_yesterday:
            return True
        
        return False
    except Exception as e:
        print(f"[ERROR] check_missed_day: {e}")
        return False


def get_user_spell_data(user_id: int) -> dict:
    """Ottiene i dati degli incantesimi per un utente"""
    data = load_tracker_data()
    user_key = str(user_id)
    
    if user_key not in data:
        data[user_key] = {
            'active_works': {},
            'completed_works': [],
            'total_sessions': 0,
            'total_reps': 0,
            'streak_days': 0,
            'last_session_date': None
        }
        save_tracker_data(data)
    
    return data[user_key]


def start_spell_work(user_id: int, spell_id: str, spell_info: dict) -> dict:
    """
    Inizia un nuovo lavoro o ritorna quello esistente.
    Controlla anche se deve entrare in recovery mode.
    """
    data = load_tracker_data()
    user_key = str(user_id)
    
    if user_key not in data:
        data[user_key] = {
            'active_works': {},
            'completed_works': [],
            'total_sessions': 0,
            'total_reps': 0,
            'streak_days': 0,
            'last_session_date': None
        }
    
    user_data = data[user_key]
    now = datetime.now()
    
    # Se esiste gi√† un lavoro attivo
    if spell_id in user_data['active_works']:
        work = user_data['active_works'][spell_id]
        
        # Solo per lavori con durata > 0
        if work.get('duration_days', 0) > 0:
            # Controlla se ha saltato un giorno
            if check_missed_day(work) and not work.get('recovery_mode') and not work.get('recovery_used'):
                # Attiva recovery mode!
                work['recovery_mode'] = True
                work['recovery_first_session'] = None
                user_data['active_works'][spell_id] = work
                save_tracker_data(data)
                
                return {
                    'status': 'recovery_needed',
                    'message': '‚ö†Ô∏è Hai saltato un giorno! Puoi recuperare facendo 2 sessioni oggi (a 6 ore di distanza).',
                    'work': work
                }
            
            # Se gi√† in recovery mode ma non ha ancora fatto prima sessione
            if work.get('recovery_mode') and not work.get('recovery_first_session'):
                return {
                    'status': 'recovery_needed',
                    'message': '‚ö†Ô∏è Modalit√† recupero attiva. Completa la prima sessione.',
                    'work': work
                }
            
            # Se in recovery e ha fatto prima sessione, controlla 6 ore
            if work.get('recovery_mode') and work.get('recovery_first_session'):
                first_dt = datetime.fromisoformat(work['recovery_first_session'])
                hours_passed = (now - first_dt).total_seconds() / 3600
                
                if hours_passed < 6:
                    remaining = 6 - hours_passed
                    hours = int(remaining)
                    mins = int((remaining - hours) * 60)
                    return {
                        'status': 'recovery_wait',
                        'message': f'‚è≥ Attendi ancora {hours}h {mins}m per la seconda sessione di recupero.',
                        'work': work
                    }
                else:
                    return {
                        'status': 'recovery_second',
                        'message': '‚úÖ Puoi fare la seconda sessione di recupero!',
                        'work': work
                    }
        
        return {
            'status': 'existing',
            'work': work
        }
    
    # Crea nuovo lavoro
    duration = spell_info.get('duration_days', 0) or 0
    
    new_work = {
        'spell_id': spell_id,
        'spell_name': spell_info.get('name', spell_id),
        'category': spell_info.get('category', 'mantra'),
        'duration_days': duration,
        'reps_per_session': spell_info.get('reps_per_session', 108),
        'affirmation': spell_info.get('affirmation', ''),
        'aff_reps': spell_info.get('aff_reps', 3),
        'start_date': now.isoformat(),
        'start_day_of_week': now.strftime('%A'),
        'current_day': 1,
        'total_days': duration,
        'sessions': [],
        'status': 'active',
        'last_completed': None,
        'recovery_mode': False,
        'recovery_first_session': None,
        'recovery_used': False,
        'end_date': None
    }
    
    user_data['active_works'][spell_id] = new_work
    save_tracker_data(data)
    
    return {
        'status': 'new',
        'work': new_work
    }


def record_spell_session(
    user_id: int, 
    spell_id: str, 
    reps_done: int,
    aff_done: int = 0,
    planetary_hour: str = None,
    duration_seconds: int = 0
) -> dict:
    """
    Registra una sessione completata.
    Gestisce anche recovery mode.
    """
    data = load_tracker_data()
    user_key = str(user_id)
    
    if user_key not in data:
        return {'error': True, 'message': 'Utente non trovato'}
    
    user_data = data[user_key]
    now = datetime.now()
    
    # Crea lavoro se non esiste (per incantesimi senza durata)
    if spell_id not in user_data['active_works']:
        # Per incantesimi singoli senza durata
        user_data['active_works'][spell_id] = {
            'spell_id': spell_id,
            'spell_name': spell_id,
            'category': 'unknown',
            'duration_days': 0,
            'reps_per_session': reps_done,
            'current_day': 0,
            'total_days': 0,
            'sessions': [],
            'status': 'active',
            'last_completed': None,
            'start_date': now.isoformat()
        }
    
    work = user_data['active_works'][spell_id]
    duration_days = work.get('duration_days', 0)
    
    # === GESTIONE RECOVERY MODE ===
    if work.get('recovery_mode') and duration_days > 0:
        first_session = work.get('recovery_first_session')
        
        if first_session:
            # SECONDA sessione di recupero
            first_dt = datetime.fromisoformat(first_session)
            hours_passed = (now - first_dt).total_seconds() / 3600
            
            if hours_passed < 6:
                remaining = 6 - hours_passed
                hours = int(remaining)
                mins = int((remaining - hours) * 60)
                return {
                    'status': 'recovery_wait',
                    'message': f'‚è≥ Devi aspettare ancora {hours}h {mins}m per la seconda sessione.'
                }
            
            # Completa recovery!
            work['recovery_mode'] = False
            work['recovery_used'] = True
            work['recovery_completed'] = now.isoformat()
            work['last_completed'] = now.isoformat()
            work['current_day'] += 1
            
            # Registra sessione
            session = {
                'date': now.isoformat(),
                'day_of_week': now.strftime('%A'),
                'time': now.strftime('%H:%M'),
                'reps_done': reps_done,
                'aff_done': aff_done,
                'planetary_hour': planetary_hour,
                'duration_seconds': duration_seconds,
                'day_number': work['current_day'],
                'is_recovery': True,
                'recovery_session': 2
            }
            work['sessions'].append(session)
            
            # Statistiche
            user_data['total_sessions'] += 1
            user_data['total_reps'] += reps_done
            
            # Verifica completamento
            if work['current_day'] > work['total_days']:
                work['status'] = 'completed'
                work['end_date'] = now.isoformat()
                user_data['completed_works'].append(work.copy())
                del user_data['active_works'][spell_id]
                save_tracker_data(data)
                
                return {
                    'status': 'work_completed',
                    'message': 'üéâ Lavoro completato!',
                    'work': work,
                    'streak': user_data.get('streak_days', 1)
                }
            
            save_tracker_data(data)
            
            return {
                'status': 'recovery_complete',
                'message': f'‚úÖ Recupero completato! Ora sei al giorno {work["current_day"]}/{work["total_days"]}',
                'work': work,
                'streak': user_data.get('streak_days', 1)
            }
        else:
            # PRIMA sessione di recupero
            work['recovery_first_session'] = now.isoformat()
            work['current_day'] += 1
            
            # Registra sessione
            session = {
                'date': now.isoformat(),
                'day_of_week': now.strftime('%A'),
                'time': now.strftime('%H:%M'),
                'reps_done': reps_done,
                'aff_done': aff_done,
                'planetary_hour': planetary_hour,
                'duration_seconds': duration_seconds,
                'day_number': work['current_day'],
                'is_recovery': True,
                'recovery_session': 1
            }
            work['sessions'].append(session)
            
            user_data['total_sessions'] += 1
            user_data['total_reps'] += reps_done
            
            save_tracker_data(data)
            
            next_session = now + timedelta(hours=6)
            return {
                'status': 'recovery_first_done',
                'message': f'‚úÖ Prima sessione di recupero completata!\n\nFai la seconda sessione dopo le {next_session.strftime("%H:%M")}',
                'work': work,
                'streak': user_data.get('streak_days', 1)
            }
    
    # === CONTROLLO NORMALE: gi√† fatto oggi? ===
    if duration_days > 0 and check_already_done_today(work):
        dawn = get_dawn_today()
        if now.hour < 6:
            next_dawn = dawn
        else:
            next_dawn = dawn + timedelta(days=1)
        
        hours_left = int((next_dawn - now).total_seconds() // 3600)
        mins_left = int(((next_dawn - now).total_seconds() % 3600) // 60)
        
        return {
            'status': 'already_done_today',
            'message': f'‚úÖ Hai gi√† completato la sessione di oggi!\n\nüåÖ Prossima alba tra {hours_left}h {mins_left}m',
            'work': work
        }
    
    # === REGISTRA SESSIONE NORMALE ===
    work['last_completed'] = now.isoformat()
    if duration_days > 0:
        work['current_day'] += 1
    
    session = {
        'date': now.isoformat(),
        'day_of_week': now.strftime('%A'),
        'time': now.strftime('%H:%M'),
        'reps_done': reps_done,
        'aff_done': aff_done,
        'planetary_hour': planetary_hour,
        'duration_seconds': duration_seconds,
        'day_number': work.get('current_day', 1)
    }
    work['sessions'].append(session)
    
    # Statistiche globali
    user_data['total_sessions'] += 1
    user_data['total_reps'] += reps_done
    
    # Aggiorna streak
    last_date = user_data.get('last_session_date')
    if last_date:
        try:
            last = datetime.fromisoformat(last_date).date()
            if (now.date() - last).days == 1:
                user_data['streak_days'] = user_data.get('streak_days', 0) + 1
            elif (now.date() - last).days > 1:
                user_data['streak_days'] = 1
        except:
            user_data['streak_days'] = 1
    else:
        user_data['streak_days'] = 1
    
    user_data['last_session_date'] = now.isoformat()
    
    # Verifica completamento lavoro
    if duration_days > 0 and work['current_day'] > work['total_days']:
        work['status'] = 'completed'
        work['end_date'] = now.isoformat()
        user_data['completed_works'].append(work.copy())
        del user_data['active_works'][spell_id]
        save_tracker_data(data)
        
        return {
            'status': 'work_completed',
            'message': f'üéâ Lavoro completato! {work["total_days"]} giorni!',
            'work': work,
            'streak': user_data['streak_days']
        }
    
    save_tracker_data(data)
    
    return {
        'status': 'session_recorded',
        'session': session,
        'work': work,
        'streak': user_data['streak_days']
    }


def get_spell_work(user_id: int, spell_id: str) -> Optional[dict]:
    """Ottiene un lavoro specifico"""
    user_data = get_user_spell_data(user_id)
    
    if spell_id in user_data['active_works']:
        return user_data['active_works'][spell_id]
    
    for work in user_data['completed_works']:
        if work.get('spell_id') == spell_id:
            return work
    
    return None


def can_do_session_today(user_id: int, spell_id: str) -> dict:
    """Controlla se pu√≤ fare la sessione oggi"""
    user_data = get_user_spell_data(user_id)
    now = datetime.now()
    
    if spell_id not in user_data['active_works']:
        return {'can_do': True, 'reason': 'new_work'}
    
    work = user_data['active_works'][spell_id]
    
    # Per lavori senza durata
    if work.get('duration_days', 0) == 0:
        return {'can_do': True, 'reason': 'no_duration'}
    
    # Se in recovery mode
    if work.get('recovery_mode'):
        first_session = work.get('recovery_first_session')
        if first_session:
            first_dt = datetime.fromisoformat(first_session)
            hours_passed = (now - first_dt).total_seconds() / 3600
            if hours_passed >= 6:
                return {'can_do': True, 'reason': 'recovery_second'}
            else:
                remaining = 6 - hours_passed
                hours = int(remaining)
                mins = int((remaining - hours) * 60)
                return {
                    'can_do': False, 
                    'reason': 'recovery_wait',
                    'message': f'Attendi {hours}h {mins}m per la seconda sessione'
                }
        else:
            return {'can_do': True, 'reason': 'recovery_first'}
    
    # Controlla se gi√† fatto oggi
    if check_already_done_today(work):
        dawn = get_dawn_today()
        if now.hour < 6:
            next_dawn = dawn
        else:
            next_dawn = dawn + timedelta(days=1)
        
        hours_left = int((next_dawn - now).total_seconds() // 3600)
        mins_left = int(((next_dawn - now).total_seconds() % 3600) // 60)
        
        return {
            'can_do': False, 
            'reason': 'already_done',
            'message': f'Gi√† fatto oggi! Prossima alba tra {hours_left}h {mins_left}m'
        }
    
    # Controlla se ha saltato un giorno
    if check_missed_day(work) and not work.get('recovery_used'):
        return {
            'can_do': True,
            'reason': 'missed_day',
            'message': 'Hai saltato un giorno! Puoi recuperare con 2 sessioni oggi.'
        }
    
    return {'can_do': True, 'reason': 'ok'}


def get_active_spell_works(user_id: int) -> List[dict]:
    """Ritorna lista dei lavori attivi"""
    user_data = get_user_spell_data(user_id)
    works = []
    
    for spell_id, work in user_data['active_works'].items():
        work['days_remaining'] = max(0, work.get('total_days', 0) - work.get('current_day', 0) + 1)
        work['done_today'] = check_already_done_today(work) if work.get('duration_days', 0) > 0 else False
        works.append(work)
    
    return works


def get_spell_stats(user_id: int) -> dict:
    """Ritorna statistiche globali"""
    user_data = get_user_spell_data(user_id)
    
    return {
        'total_sessions': user_data.get('total_sessions', 0),
        'total_reps': user_data.get('total_reps', 0),
        'streak_days': user_data.get('streak_days', 0),
        'active_works_count': len(user_data.get('active_works', {})),
        'completed_works_count': len(user_data.get('completed_works', []))
    }


def reset_spell_work(user_id: int, spell_id: str) -> bool:
    """Reset di un lavoro (admin/test)"""
    data = load_tracker_data()
    user_key = str(user_id)
    
    if user_key in data and spell_id in data[user_key].get('active_works', {}):
        del data[user_key]['active_works'][spell_id]
        save_tracker_data(data)
        return True
    
    return False
